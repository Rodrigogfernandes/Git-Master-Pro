[
  {
    "id": 0,
    "title": "1. Init (Inicializar RepositÃ³rio)",
    "tutorial": {
      "desc": "Todo projeto Git comeÃ§a com `git init`. Esse comando cria a infraestrutura necessÃ¡ria (a pasta oculta .git) que armazena todo o histÃ³rico do seu projeto. Ã‰ o primeiro passo para comeÃ§ar a usar controle de versÃ£o.",
      "detailed": "Quando vocÃª executa `git init`, Git cria um novo repositÃ³rio local. Isso inclui arquivos de configuraÃ§Ã£o, hooks e histÃ³rico de commits. A pasta .git Ã© onde tudo Ã© armazenado.",
      "tips": "Execute este comando uma Ãºnica vez por projeto. NÃ£o precisa executar dentro de repositÃ³rios jÃ¡ criados.",
      "diagram": "ğŸ“ Pasta do Projeto\n    â†“\nâš™ï¸ git init\n    â†“\nğŸ“‚ .git/ criado â€” repositÃ³rio inicializado",
      "example": "git init"
    },
    "mission": {
      "desc": "VocÃª estÃ¡ na pasta do seu novo projeto. Transforme-a em um repositÃ³rio Git.",
      "goal": "Digite o comando para inicializar o repositÃ³rio.",
      "steps": ["1. Abra o terminal", "2. Navegue atÃ© a pasta do projeto", "3. Digite: git init", "4. Pressione Enter"],
      "expected": "git init",
      "success": "RepositÃ³rio inicializado com sucesso em /projeto/.git"
    }
  },
  {
    "id": 1,
    "title": "2. Clone (Clonar RepositÃ³rio)",
    "tutorial": {
      "desc": "`git clone` copia um repositÃ³rio remoto completamente para sua mÃ¡quina. Ã‰ usado para baixar projetos existentes ou comeÃ§ar a colaborar.",
      "detailed": "Clone faz download de todo o histÃ³rico, branches e configuraÃ§Ãµes. Cria uma pasta com o nome do projeto. Configura automaticamente 'origin' apontando para o repositÃ³rio remoto. VocÃª fica pronto para trabalhar imediatamente.",
      "tips": "Clone cria uma cÃ³pia completa - nenhuma permissÃ£o especial necessÃ¡ria para projetos pÃºblicos. VocÃª pode clonar quantos repositÃ³rios quiser. Clone cria uma pasta, entÃ£o execute em um diretÃ³rio pai.",
      "diagram": "ğŸŒ RepositÃ³rio no GitHub\n        â†“\nâ¬‡ï¸ git clone URL\n        â†“\nğŸ“¥ Download completo\n    (histÃ³rico, branches, configs)\n        â†“\nğŸ“ RepositÃ³rio Local (pronto para usar)",
      "example": "git clone https://github.com/user/repositorio.git\nou\ngit clone git@github.com:user/repo.git"
    },
    "mission": {
      "desc": "Clone um repositÃ³rio remoto para sua mÃ¡quina local.",
      "goal": "Clone o repositÃ³rio usando a URL fornecida.",
      "steps": ["1. Copie a URL do repositÃ³rio no GitHub", "2. Digite: git clone URL", "3. Aguarde o download", "4. Acesse a pasta: cd nome-do-repo"],
      "expected": "git clone https://github.com/user/repositorio.git",
      "success": "RepositÃ³rio clonado com sucesso!"
    }
  },
  {
    "id": 2,
    "title": "3. Status â€” Verificar estado",
    "tutorial": {
      "desc": "`git status` Ã© seu melhor amigo! Ele mostra o estado atual do repositÃ³rio: quais arquivos foram modificados, quais estÃ£o preparados para commit (staged) e quais ainda nÃ£o foram rastreados.",
      "detailed": "Este comando fornece informaÃ§Ãµes sobre: (1) Arquivos nÃ£o rastreados - novos arquivos que Git nÃ£o conhece, (2) MudanÃ§as nÃ£o preparadas - arquivos modificados mas nÃ£o adicionados ao stage, (3) MudanÃ§as preparadas - arquivos prontos para serem commitados.",
      "tips": "Execute este comando frequentemente para acompanhar o estado do seu trabalho. Use `git status -s` para uma versÃ£o mais compacta.",
      "diagram": "ğŸ“ Modificar arquivo\n    â†“\nğŸ” git status\n    â†“\nMostra: M (modified), A (added), ?? (untracked)",
      "example": "git status"
    },
    "mission": {
      "desc": "Veja o estado atual do seu repositÃ³rio e entenda quais arquivos foram alterados.",
      "goal": "Use o comando para verificar o status do repositÃ³rio.",
      "steps": ["1. Digite: git status", "2. Observe quais arquivos estÃ£o modificados", "3. Entenda o significado das cores/marcas"],
      "expected": "git status",
      "success": "Status listado com sucesso."
    }
  },
  {
    "id": 3,
    "title": "4. Add (Preparar stage)",
    "tutorial": {
      "desc": "Use `git add` para colocar arquivos na Ã¡rea de stage (preparaÃ§Ã£o). O stage Ã© uma Ã¡rea intermediÃ¡ria entre seu workspace (pasta de trabalho) e seu commit (salvamento permanente).",
      "detailed": "O comando `git add` marca os arquivos que vocÃª quer incluir no prÃ³ximo commit. VocÃª pode adicionar arquivos especÃ­ficos ou todos os arquivos de uma vez. O stage permite revisar o que serÃ¡ commitado antes de tornar permanente.",
      "tips": "Use `git add .` para adicionar todos os arquivos modificados, ou `git add arquivo.txt` para um arquivo especÃ­fico. `git add -p` permite revisar cada mudanÃ§a antes de adicionar.",
      "diagram": "ğŸ’» Working Directory (modificaÃ§Ãµes)\n    â†“\nâ• git add\n    â†“\nğŸ—‚ï¸ Staging Area (preparado)\n    â†“\nâœ… git commit\n    â†“\nğŸ“¦ Repository (permanente)",
      "example": "git add arquivo.txt\nou\ngit add .\nou\ngit add -u"
    },
    "mission": {
      "desc": "Adicione arquivos modificados Ã  Ã¡rea de stage para preparÃ¡-los para o commit.",
      "goal": "Adicione o arquivo style.css ao stage.",
      "steps": ["1. Modifique o arquivo style.css", "2. Digite: git add style.css", "3. Verifique com: git status"],
      "expected": "git add style.css",
      "success": "Arquivo adicionado ao stage com sucesso!"
    }
  },
  {
    "id": 4,
    "title": "5. Commit (Salvar)",
    "tutorial": {
      "desc": "`git commit` grava permanentemente as mudanÃ§as preparadas (staged) no repositÃ³rio. Ã‰ como um ponto de salvamento do seu projeto com uma mensagem descritiva.",
      "detailed": "Todo commit cria um snapshot do seu projeto naquele momento. Ã‰ essencial escrever mensagens claras e descritivas para que vocÃª (e outros) entendam o que foi alterado. Um bom commit descreve 'por quÃª' a mudanÃ§a foi feita, nÃ£o apenas 'o quÃª'.",
      "tips": "Mensagens de commit devem ser concisas mas descritivas. Use `git commit -m` para mensagens curtas ou `git commit` para um editor abrir mensagens mais longas. Evite commits genÃ©ricos como 'alteraÃ§Ãµes'.",
      "diagram": "ğŸ—‚ï¸ Staging Area (preparado)\n    â†“\nğŸ“ git commit -m \"mensagem\"\n    â†“\nğŸ“Œ Commit criado\n    â†“\nğŸ“œ HistÃ³rico do Git (permanente)",
      "example": "git commit -m \"Adiciona estilos iniciais CSS\"\nou\ngit commit -am \"Atualiza estilos\""
    },
    "mission": {
      "desc": "FaÃ§a um commit dos arquivos que estÃ£o na Ã¡rea de stage com uma mensagem descritiva.",
      "goal": "Commit com mensagem clara descrevendo as mudanÃ§as.",
      "steps": ["1. Tenha arquivos no stage (use git add)", "2. Digite: git commit -m \"estilos iniciais\"", "3. Verifique o histÃ³rico: git log"],
      "expected": "git commit -m \"estilos iniciais\"",
      "success": "Commit criado e salvo permanentemente!"
    }
  },
  {
    "id": 5,
    "title": "6. RM (Remover Arquivos)",
    "tutorial": {
      "desc": "`git rm` remove permanentemente um arquivo do repositÃ³rio e do seu disco. Ã‰ diferente de apenas deletar o arquivo - Git registra a remoÃ§Ã£o como uma alteraÃ§Ã£o que pode ser commitada.",
      "detailed": "Existem trÃªs formas de lidar com arquivos: (1) `git rm` - remove do Git e do disco, (2) `git rm --cached` - remove do Git mas mantÃ©m no disco, (3) Deletar manualmente - Git detecta como modificaÃ§Ã£o. Sempre use `git rm` para manter o histÃ³rico consistente.",
      "tips": "NÃ£o delete arquivos manualmente e depois commit. Use `git rm` para que Git registre a remoÃ§Ã£o. Use `git rm -r` para remover diretÃ³rios.",
      "diagram": "ğŸ“„ Arquivo no repositÃ³rio\n    â†“\nğŸ—‘ï¸ git rm arquivo\n    â†“\nâš ï¸ Arquivo marcado para remoÃ§Ã£o\n    â†“\nâœ… git commit\n    â†“\nğŸ§¾ RemoÃ§Ã£o registrada no histÃ³rico",
      "example": "git rm arquivo.txt\nou\ngit rm -r pasta/\nou\ngit rm --cached arquivo.txt"
    },
    "mission": {
      "desc": "Remova um arquivo indesejado do repositÃ³rio registrando a exclusÃ£o no Git.",
      "goal": "Remova o arquivo lixo.tmp do repositÃ³rio.",
      "steps": ["1. Identifique o arquivo a remover", "2. Digite: git rm lixo.tmp", "3. Commit a remoÃ§Ã£o: git commit -m \"Remove arquivo temporÃ¡rio\""],
      "expected": "git rm lixo.tmp",
      "success": "Arquivo removido e remoÃ§Ã£o registrada no Git!"
    }
  },
  {
    "id": 6,
    "title": "7. Branch (Criar e Trocar)",
    "tutorial": {
      "desc": "Branches sÃ£o versÃµes paralelas do seu cÃ³digo. `git checkout -b` cria uma nova branch e jÃ¡ muda para ela. Isso permite trabalhar em novas features sem afetar a branch principal (master/main).",
      "detailed": "Uma branch Ã© um ponteiro para um commit especÃ­fico. Ao criar uma branch, vocÃª cria um linha de desenvolvimento independente. Isso Ã© essencial em times: cada pessoa trabalha em sua branch, depois faz merge na principal. As branches sÃ£o muito leves e baratas de criar.",
      "tips": "Nome de branches em minÃºsculas com hÃ­fens (feature-login, bugfix-crash). Use `git branch -a` para ver todas as branches. A branch atual tem um asterisco (*). Sempre faÃ§a commit antes de trocar de branch.",
      "diagram": "ğŸŒ³ Master (principal)\n    |\n    +--- âœ¨ nova-feature (branch paralela)\n    |        |\n    |        +--- ğŸ”¢ commit 1\n    |        |\n    |        +--- ğŸ”¢ commit 2\n    |\n    +--- ğŸ”¢ commit no master",
      "example": "git checkout -b nova-feature\nou\ngit switch -c nova-feature\nou\ngit branch nova-feature && git checkout nova-feature"
    },
    "mission": {
      "desc": "Crie uma nova branch paralela para trabalhar em uma funcionalidade sem afetar a branch principal.",
      "goal": "Crie e mude para a branch 'login'.",
      "steps": ["1. Digite: git checkout -b login", "2. Verifique: git branch (verÃ¡ * login)", "3. Trabalhe na branch", "4. Para voltar: git checkout master"],
      "expected": "git checkout -b login ou git switch -c login",
      "success": "Branch login criada e ativada com sucesso!"
    }
  },
  {
    "id": 7,
    "title": "8. Checkout/Switch (Mudar de Branch)",
    "tutorial": {
      "desc": "Mude entre branches usando `git checkout` ou `git switch`. Permite trabalhar em diferentes versÃµes do cÃ³digo sem afetar outras branches.",
      "detailed": "`git checkout branch-name` Ã© o comando clÃ¡ssico. `git switch branch-name` Ã© a sintaxe mais nova (Git 2.23+). Ambos fazem a mesma coisa. O working directory muda para o estado da branch escolhida.",
      "tips": "Sempre commit ou stash antes de trocar de branch. Use `git switch -c branch-name` para criar e trocar simultaneamente. Use `git switch -` para voltar Ã  branch anterior (como `cd -`). Verifique em qual branch estÃ¡ com `git status` ou `git branch`.",
      "diagram": "ğŸŒ³ Branch Master\n    |  \n    |  (git switch feature-login)\n    |  â†“\n    â””â”€â†’ âœ¨ Branch Feature-Login\n    \nğŸ’» Working Dir muda\nArquivos refletem a branch",
      "example": "git switch login\nou\ngit checkout login\nou\ngit switch -c nova-branch\nou\ngit switch -"
    },
    "mission": {
      "desc": "Mude para uma branch diferente.",
      "goal": "Troque para a branch 'login' de forma segura.",
      "steps": ["1. Commit ou stash suas mudanÃ§as", "2. Verifique branches: git branch", "3. Digite: git switch login ou git checkout login", "4. Confirme: git status (vocÃª estÃ¡ em login)"],
      "expected": "git switch login",
      "success": "Mudou para a branch login com sucesso!"
    }
  },
  {
    "id": 8,
    "title": "9. branch --list (Listar Branches)",
    "tutorial": {
      "desc": "`git branch` lista todas as branches locais. O `-a` flag mostra tambÃ©m as branches remotas. A branch atual Ã© marcada com um asterisco (*).",
      "detailed": "Cada repositÃ³rio pode ter mÃºltiplas branches. `git branch` lista apenas locais, `git branch -a` lista locais e remotas, `git branch -r` lista apenas remotas. VocÃª pode deletar branches com `git branch -d` ou forÃ§ar com `-D`.",
      "tips": "Mantenha suas branches organizadas. Delete branches antigas e sem uso. Use `git branch -v` para ver o Ãºltimo commit de cada branch. Use `git branch -m` para renomear uma branch.",
      "diagram": "ğŸ“ RepositÃ³rio Local\n  â”œâ”€â”€ master (branch principal)\n  â”œâ”€â”€ login (sua branch)\n  â”œâ”€â”€ feature-cart (outra branch)\n  â””â”€â”€ bugfix-crash (mais uma)\n\n* login (vocÃª estÃ¡ aqui)",
      "example": "git branch\nou\ngit branch -a\nou\ngit branch -v"
    },
    "mission": {
      "desc": "Liste todas as branches disponÃ­veis e entenda a estrutura do repositÃ³rio.",
      "goal": "Execute o comando para ver todas as branches.",
      "steps": ["1. Digite: git branch -a", "2. Observe a lista de branches", "3. A * indica sua branch atual"],
      "expected": "git branch",
      "success": "Branches listadas com sucesso!"
    }
  },
  {
    "id": 9,
    "title": "10. Branch (RamificaÃ§Ã£o)",
    "tutorial": {
      "desc": "Crie branches de desenvolvimento sem afetar a versÃ£o principal. Cada branch pode ter sua prÃ³pria sÃ©rie de commits, permitindo desenvolvimento paralelo e organizado.",
      "detailed": "Branches sÃ£o cruciais para desenvolvimento em equipe. Cada desenvolvedor cria sua branch para uma feature ou correÃ§Ã£o, trabalha independentemente, e depois integra (merge) na branch principal. Isso mantÃ©m a branch master/main sempre funcional.",
      "tips": "Nomeie branches descritivamente: feature-autenticacao, bugfix-login-erro, hotfix-performance. Crie uma branch por feature/correÃ§Ã£o. NÃ£o trabalhe diretamente na master em projetos colaborativos.",
      "diagram": "ğŸŒ³ Master (versÃ£o estÃ¡vel)\n    â†“\nâ• Criar branch\n    â†“\nğŸ’» Trabalhar na branch\n",
      "example": "git branch nova-feature\n"
    },
    "mission": {
      "desc": "Crie uma nova branch para trabalhar em uma funcionalidade especÃ­fica.",
      "goal": "Crie a branch 'login' para desenvolvimento da funcionalidade de login.",
      "steps": ["1. Certifique-se que estÃ¡ na master", "2. Digite: git branch login", "3. Troque para a branch: git checkout login"],
      "expected": "git branch login",
      "success": "Branch login criada com sucesso!"
    }
  },
  {
    "id": 10,
    "title": "11. Merge (FusÃ£o de Branches)",
    "tutorial": {
      "desc": "`git merge` integra mudanÃ§as de uma branch para outra. Tipicamente, vocÃª faz merge de uma feature-branch de volta para a master apÃ³s terminar o trabalho.",
      "detailed": "Merge combina o histÃ³rico de duas branches. O Git encontra um commit comum e aplica as mudanÃ§as. Em casos sem conflitos, Ã© automÃ¡tico. Com conflitos (mesmas linhas modificadas), vocÃª precisa resolvÃª-los manualmente.",
      "tips": "Sempre faÃ§a merge na branch correta. Primeiro troque para a branch de destino (geralmente master), depois faÃ§a merge. Revise os commits antes de fazer merge. Use `git merge --no-ff` para criar um commit de merge mesmo sem conflitos.",
      "diagram": "âœ¨ Feature Branch          ğŸŒ³ Master Branch\n    |                    |\n    +-- ğŸ”¢ commit 1         |\n    |                    |\n    +-- ğŸ”¢ commit 2         |\n    |                    |\n    +-- (HEAD)      git merge feature\n         |              â†“\n         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ (traz commits 1 e 2)",
      "example": "git merge login\nou\ngit merge --no-ff login\nou\ngit merge -m \"Merge feature login\" login"
    },
    "mission": {
      "desc": "Integre as mudanÃ§as de uma branch de volta para a master apÃ³s terminar o desenvolvimento.",
      "goal": "FaÃ§a merge da branch 'login' para a master.",
      "steps": ["1. Primeiro volte para master: git checkout master", "2. Digite: git merge login", "3. Resolva conflitos se houver", "4. Verifique: git log"],
      "expected": "git checkout master",
      "success": "Merge realizado com sucesso! Branch integrada na master!"
    }
  },
  {
    "id": 11,
    "title": "12. Diff (DiferenÃ§as)",
    "tutorial": {
      "desc": "`git diff` mostra as mudanÃ§as exatas entre sua versÃ£o atual e a versÃ£o anterior. VocÃª pode ver linha por linha o que foi alterado, removido ou adicionado.",
      "detailed": "O `git diff` compara o working directory com o stage. Use `git diff --staged` para ver mudanÃ§as jÃ¡ no stage. Use `git diff HEAD` para comparar com o Ãºltimo commit. Linhas com '-' foram removidas, linhas com '+' foram adicionadas.",
      "tips": "Use `git diff | head -50` para ver apenas as primeiras 50 linhas. Use `git diff arquivo.txt` para ver diferenÃ§as de um arquivo especÃ­fico. Muito Ãºtil antes de fazer commit para revisar exatamente o que vocÃª mudou.",
      "diagram": "ğŸ“¦ Ãšltima versÃ£o commitada\n    â†“ (diferenÃ§a)\nğŸ’» VersÃ£o atual no working dir\n\ngit diff mostra:\n  - Linhas removidas (com -)\n  + Linhas adicionadas (com +)",
      "example": "git diff\nou\ngit diff --staged\nou\ngit diff arquivo.txt"
    },
    "mission": {
      "desc": "Visualize as mudanÃ§as exatas feitas em um arquivo usando diff.",
      "goal": "Veja as diferenÃ§as entre a versÃ£o anterior e a atual.",
      "steps": ["1. Modifique o arquivo style.css", "2. Digite: git diff style.css", "3. Revise as linhas adicionadas (+) e removidas (-)"],
      "expected": "git diff",
      "success": "DiferenÃ§as exibidas com sucesso!"
    }
  },
  {
    "id": 12,
    "title": "13. Restore (Restaurar Arquivos)",
    "tutorial": {
      "desc": "`git restore` desfaz alteraÃ§Ãµes em um arquivo especÃ­fico. Ã‰ Ãºtil quando vocÃª faz mudanÃ§as mas quer descartar tudo e voltar Ã  versÃ£o anterior.",
      "detailed": "Existem trÃªs escopos: (1) `git restore arquivo` - desfaz mudanÃ§as no working directory, (2) `git restore --staged arquivo` - remove arquivo do stage mas mantÃ©m as mudanÃ§as localmente, (3) `git restore HEAD~1 arquivo` - restaura versÃ£o de um commit anterior.",
      "tips": "Use com cuidado! `git restore` descarta mudanÃ§as permanentemente. Se nÃ£o tiver commitado, as mudanÃ§as sÃ£o perdidas. Use `git checkout --` para restaurar (sintaxe antiga) ou `git restore` (sintaxe nova).",
      "diagram": "âœï¸ Arquivo modificado (nÃ£o commitado)\n    â†“\nğŸ› ï¸ git restore arquivo.txt\n    â†“\nğŸ“„ Arquivo volta ao estado anterior\n    â†“\nâŒ MudanÃ§as descartadas",
      "example": "git restore arquivo.txt\nou\ngit restore --staged arquivo.txt\nou\ngit restore --source=HEAD~1 arquivo.txt"
    },
    "mission": {
      "desc": "DesfaÃ§a mudanÃ§as em um arquivo que foi acidentalmente modificado.",
      "goal": "Restaure o arquivo index.html para seu estado anterior.",
      "steps": ["1. Verifique o estado: git status", "2. Digite: git restore index.html", "3. Confirme: git status (arquivo restaurado)"],
      "expected": "git restore index.html",
      "success": "AlteraÃ§Ãµes desfeitas com sucesso!"
    }
  },
  {
    "id": 13,
    "title": "14. Reset (Voltar no Tempo)",
    "tutorial": {
      "desc": "`git reset` move o ponteiro HEAD para um commit anterior e pode alterar o stage e o working directory. Use com cuidado - Ã© uma operaÃ§Ã£o poderosa!",
      "detailed": "TrÃªs modos de reset: (1) `--soft` - move HEAD, mantÃ©m mudanÃ§as no stage, (2) `--mixed` (padrÃ£o) - move HEAD e remove do stage, (3) `--hard` - move HEAD, descarta tudo. HEAD~1 significa 1 commit antes, HEAD~3 significa 3 commits antes.",
      "tips": "Use `git reset --soft HEAD~1` para desfazer o Ãºltimo commit mas manter as mudanÃ§as. Use `--hard` com cuidado! MudanÃ§as sÃ£o perdidas. Nunca use reset em commits jÃ¡ enviados (push) para repositÃ³rios compartilhados.",
      "diagram": "âª Commit 3 (HEAD)\n    â†“\nğŸ” git reset --hard HEAD~1\n    â†“\nâ¹ï¸ Commit 2 (novo HEAD)\nğŸ—‘ï¸ Commit 3 Ã© removido",
      "example": "git reset --soft HEAD~1\nou\ngit reset HEAD\nou\ngit reset --hard HEAD~1"
    },
    "mission": {
      "desc": "Volte 1 commit no tempo, desfazendo o Ãºltimo commit.",
      "goal": "Use git reset para desfazer o Ãºltimo commit.",
      "steps": ["1. Verifique o histÃ³rico: git log", "2. Digite: git reset --hard HEAD~1", "3. Confirme: git log (Ãºltimo commit removido)"],
      "expected": "git reset --hard HEAD~1",
      "success": "RepositÃ³rio revertido um commit para trÃ¡s!"
    }
  },
  {
    "id": 14,
    "title": "15. Stash (Guardar Trabalho)",
    "tutorial": {
      "desc": "`git stash` guarda temporariamente suas mudanÃ§as sem fazer commit. Ã‰ como colocar seu trabalho em uma prateleira para retomar depois.",
      "detailed": "Stash Ã© Ãºtil quando: (1) precisa trocar de branch urgentemente mas nÃ£o terminou o trabalho, (2) quer voltar ao estado limpo do repositÃ³rio, (3) tem conflitos ao fazer pull. Use `git stash list` para ver stashes salvos, `git stash pop` para recuperar, `git stash drop` para deletar.",
      "tips": "Stash Ã© temporÃ¡rio! Use `git stash save 'descriÃ§Ã£o'` para descrever o stash. Use `git stash apply` para aplicar sem remover. Use `git stash pop` para aplicar e remover. NÃ£o deixe stashes guardados por muito tempo.",
      "diagram": "ğŸ§° MudanÃ§as em progresso\n    â†“\nğŸ“¥ git stash\n    â†“\nğŸ“¦ MudanÃ§as guardadas (workspace limpo)\n    â†“\nFaz outra coisa\n    â†“\nğŸ“¤ git stash pop\n    â†“\nâ™»ï¸ MudanÃ§as recuperadas",
      "example": "git stash\nou\ngit stash save 'feature login em progresso'\nou\ngit stash list\nou\ngit stash pop"
    },
    "mission": {
      "desc": "Guarde temporariamente mudanÃ§as em progresso para fazer outra coisa.",
      "goal": "Use stash para guardar alteraÃ§Ãµes temporÃ¡rias.",
      "steps": ["1. FaÃ§a mudanÃ§as em um arquivo", "2. Digite: git stash", "3. Verifique: git status (workspace limpo)", "4. Recupere: git stash pop"],
      "expected": "git stash",
      "success": "AlteraÃ§Ãµes guardadas e recuperÃ¡veis a qualquer momento!"
    }
  },
  {
    "id": 15,
    "title": "16. Log (Ver HistÃ³rico)",
    "tutorial": {
      "desc": "`git log` lista o histÃ³rico de todos os commits. VocÃª pode ver quem fez cada mudanÃ§a, quando, e qual mensagem foi deixada.",
      "detailed": "O log mostra: commit hash (identificador Ãºnico), autor, data, e mensagem. Use `git log --oneline` para versÃ£o compacta, `git log --graph` para ver branches visualmente, `git log --all` para ver todas as branches. VocÃª pode filtrar por autor, data, ou mensagem.",
      "tips": "Use `git log --oneline --graph --all --decorate` para uma visÃ£o completa. Use `git log -p` para ver as mudanÃ§as de cada commit. Use `git log -p -S 'texto'` para encontrar quando um texto foi adicionado/removido.",
      "diagram": "ğŸ” commit abc123 (HEAD)\nAutor: JoÃ£o\nData: 2 dec 2025\nMensagem: Adiciona login\n    â†“\nğŸ” commit def456\nAutor: Maria\nData: 1 dec 2025\nMensagem: Inicia projeto\n    â†“\nğŸ (inÃ­cio do repositÃ³rio)",
      "example": "git log\nou\ngit log --oneline\nou\ngit log --oneline --graph --all"
    },
    "mission": {
      "desc": "Explore o histÃ³rico de commits do projeto.",
      "goal": "Visualize todos os commits e entenda o fluxo de desenvolvimento.",
      "steps": ["1. Digite: git log", "2. Veja hash, autor, data e mensagem", "3. Para visÃ£o compacta: git log --oneline", "4. Pressione 'q' para sair"],
      "expected": "git log",
      "success": "HistÃ³rico de commits exibido com sucesso!"
    }
  },
  {
    "id": 16,
    "title": "17. Remote (GitHub ConexÃ£o)",
    "tutorial": {
      "desc": "`git remote` gerencia conexÃµes com repositÃ³rios remotos (como GitHub). VocÃª usa isso para enviar (push) e receber (pull) cÃ³digo de servidores.",
      "detailed": "Um repositÃ³rio pode ter mÃºltiplos remotes. 'origin' Ã© o nome padrÃ£o para o repositÃ³rio remoto principal. Use `git remote -v` para ver as URLs. Use `git remote add nome url` para adicionar novos remotes. Cada remote precisa de URL vÃ¡lida.",
      "tips": "A URL pode ser HTTPS ou SSH. HTTPS Ã© mais fÃ¡cil para comeÃ§ar, SSH Ã© mais seguro. Use `git remote set-url origin nova-url` para alterar URL existente. Sempre configure origin antes de fazer push.",
      "diagram": "ğŸ“ RepositÃ³rio Local\n        â†“\nğŸ”— git remote add origin URL\n        â†“\nğŸŒ ConexÃ£o com GitHub\n        â†“\nğŸ”¼ Possibilita push/pull",
      "example": "git remote add origin https://github.com/user/repo.git\nou\ngit remote -v\nou\ngit remote set-url origin nova-url"
    },
    "mission": {
      "desc": "Configure a conexÃ£o com um repositÃ³rio remoto (como GitHub).",
      "goal": "Adicione o remote origin com a URL do repositÃ³rio.",
      "steps": ["1. Acesse seu repositÃ³rio no GitHub", "2. Copie a URL HTTPS", "3. Digite: git remote add origin URL", "4. Verifique: git remote -v"],
      "expected": "git remote add origin https://github.com/meu/site.git",
      "success": "Remote origin configurado com sucesso!"
    }
  },
  {
    "id": 17,
    "title": "18. Push (Enviar para GitHub)",
    "tutorial": {
      "desc": "`git push` envia seus commits locais para o repositÃ³rio remoto (GitHub). Ã‰ como fazer upload do seu trabalho para que outros possam acessar.",
      "detailed": "Push atualiza a branch remota com seus commits locais. Use `git push origin master` para enviar a branch master. Use `git push -u origin master` (primeira vez) para configurar rastreamento. VocÃª precisa ter permissÃ£o no repositÃ³rio para fazer push.",
      "tips": "Sempre faÃ§a commit antes de push. Sempre pull antes de push (para evitar conflitos). Use `git push -f` com cuidado (forÃ§a reescrita do histÃ³rico). Em repositÃ³rios compartilhados, nunca use `-f`!",
      "diagram": "ğŸ“¦ Commits locais\n    â†“\nğŸ“¤ git push -u origin master\n    â†“\nğŸ“¡ Dados sÃ£o enviados\n    â†“\nğŸŒ RepositÃ³rio remoto (GitHub)\n    â†“\nğŸ‘¥ Outros podem acessar",
      "example": "git push origin master\nou\ngit push -u origin master (primeira vez)\nou\ngit push"
    },
    "mission": {
      "desc": "Envie seus commits locais para o repositÃ³rio remoto no GitHub.",
      "goal": "FaÃ§a push da branch master para o repositÃ³rio remoto.",
      "steps": ["1. Tenha commits a enviar", "2. Digite: git push -u origin master", "3. Insira credenciais se solicitado", "4. Verifique no GitHub (commits aparecerÃ£o online)"],
      "expected": "git push -u origin master",
      "success": "Push concluÃ­do! Seu cÃ³digo estÃ¡ no GitHub!"
    }
  },
  {
    "id": 18,
    "title": "19. Pull (Receber do GitHub)",
    "tutorial": {
      "desc": "`git pull` baixa e integra (merge) mudanÃ§as do repositÃ³rio remoto. Ã‰ essencial quando trabalhando com outros - garante que vocÃª tem a versÃ£o mais recente.",
      "detailed": "Pull = Fetch + Merge. Primeiro busca as mudanÃ§as (`fetch`), depois integra (`merge`) automaticamente. Se houver conflitos, vocÃª precisa resolvÃª-los. Sempre pull antes de fazer push para evitar rejeiÃ§Ãµes.",
      "tips": "Use `git pull` frequentemente. Se houver conflitos, resolva-os manualmente. Use `git pull --rebase` para uma histÃ³ria mais limpa (cuidado se nÃ£o entende bem). Sempre commit antes de pull.",
      "diagram": "ğŸŒ RepositÃ³rio Remoto (GitHub)\n    â†“ (mudanÃ§as)\nâ¬‡ï¸ git pull\n    â†“\nğŸ” Busca mudanÃ§as (fetch)\n    â†“\nğŸ”€ Integra (merge)\n    â†“\nğŸ“ RepositÃ³rio Local atualizado",
      "example": "git pull\nou\ngit pull origin master\nou\ngit pull --rebase"
    },
    "mission": {
      "desc": "Baixe e integre as mudanÃ§as do repositÃ³rio remoto.",
      "goal": "Puxe (pull) as atualizaÃ§Ãµes do GitHub.",
      "steps": ["1. Certifique-se que estÃ¡ na branch correta", "2. Digite: git pull origin master", "3. Resolva conflitos se houver", "4. Verifique se recebeu as mudanÃ§as"],
      "expected": "git pull origin master",
      "success": "AtualizaÃ§Ãµes puxadas e integradas com sucesso!"
    }
  },
  {
    "id": 19,
    "title": "20. Fetch (Buscar sem mesclar)",
    "tutorial": {
      "desc": "`git fetch` busca atualizaÃ§Ãµes do repositÃ³rio remoto SEM aplicÃ¡-las. Ã‰ como verificar se hÃ¡ atualizaÃ§Ãµes sem instalÃ¡-las automaticamente.",
      "detailed": "Fetch atualiza referÃªncias remotas (tracking branches) mas nÃ£o altera seu working directory. Permite revisar mudanÃ§as antes de fazer merge. Use `git fetch origin` para buscar de um remote especÃ­fico. Use `git fetch --all` para todos os remotes.",
      "tips": "Fetch Ã© seguro - nunca altera seu cÃ³digo. Use antes de pull para revisar mudanÃ§as. Use `git fetch origin && git diff origin/master` para ver o que vai entrar. Ã“timo para equipes - vÃª trabalho de colegas sem afetar seu cÃ³digo.",
      "diagram": "ğŸŒ RepositÃ³rio Remoto (GitHub)\n        â†“\nğŸ”„ git fetch\n        â†“\nğŸ“¥ Download de mudanÃ§as\n(tracking branches atualizadas)\n        â†“\nâš–ï¸ Seu cÃ³digo nÃ£o Ã© alterado\n    (vocÃª revisa depois)",
      "example": "git fetch origin\nou\ngit fetch --all\nou\ngit fetch origin master"
    },
    "mission": {
      "desc": "Busque atualizaÃ§Ãµes do repositÃ³rio remoto sem aplicÃ¡-las automaticamente.",
      "goal": "Use fetch para verificar mudanÃ§as disponÃ­veis.",
      "steps": ["1. Digite: git fetch origin master", "2. Revise as mudanÃ§as: git diff origin/master", "3. Se quiser integrar: git merge origin/master"],
      "expected": "git fetch origin master",
      "success": "AtualizaÃ§Ãµes buscadas com sucesso!"
    }
  },
  {
    "id": 20,
    "title": "21. Tag (VersÃµes)",
    "tutorial": {
      "desc": "`git tag` cria marcaÃ§Ãµes permanentes de versÃµes importantes do seu projeto. Tags marcam pontos significativos como releases (v1.0, v2.0).",
      "detailed": "Existem dois tipos: (1) lightweight - apenas um ponteiro para commit, (2) annotated - contÃ©m metadados (autor, data, mensagem). Use tags para marcar versÃµes, releases, milestones. Tags nÃ£o se movem ao fazer novos commits.",
      "tips": "Use nomes semÃ¢nticos: v1.0.0, v1.0.1, v2.0.0. Use `git tag -l` para listar. Use `git tag -d` para deletar local. Use `git push origin v1.0.0` para enviar tag. Sempre marque releases importantes.",
      "diagram": "ğŸ·ï¸ commit abc - v0.9.0 (beta)\n    â†“\nğŸ”¢ commit def\n    â†“\nğŸ commit ghi - v1.0.0 (release)\n    â†“\nğŸ”§ commit jkl - v1.0.1 (hotfix)\n    â†“\nâœ¨ commit mno - v2.0.0 (nova versÃ£o)",
      "example": "git tag v1.0.0\nou\ngit tag -a v1.0.0 -m \"VersÃ£o 1.0.0 - Release\"\nou\ngit push origin v1.0.0"
    },
    "mission": {
      "desc": "Crie uma tag para marcar uma versÃ£o importante do seu projeto.",
      "goal": "Crie a tag v1.0.0 para o commit atual.",
      "steps": ["1. Certifique-se de estar no commit correto", "2. Digite: git tag v1.0.0", "3. Verifique: git tag -l", "4. Envie: git push origin v1.0.0"],
      "expected": "git tag v1.0.0",
      "success": "Tag criada com sucesso!"
    }
  },
  {
    "id": 21,
    "title": "22. Rebase (Reorganizar HistÃ³rico)",
    "tutorial": {
      "desc": "`git rebase` reorganiza a linha do tempo dos commits. Reaplica seus commits sobre uma outra branch. Resulta em um histÃ³rico mais limpo e linear.",
      "detailed": "Rebase Ã© uma alternativa ao merge. Em vez de criar um commit de merge, rebase reaplica seus commits. Ãštil para manter histÃ³rico limpo. Cuidado: rebase reescreve histÃ³rico! Nunca faÃ§a rebase em commits jÃ¡ enviados (push) para repositÃ³rios compartilhados.",
      "tips": "Use rebase para branches locais. Use merge para branches compartilhadas. `git rebase master` reaplica commits da sua branch sobre master. Se houver conflitos, resolva e continue com `git rebase --continue`. Use `git rebase -i` para reordenar/editar commits.",
      "diagram": "Antes de Rebase:\nmaster: A - B - C\nfeature:     D - E - F\n\nDepois de 'git rebase master':\nmaster: A - B - C\nfeature:         D' - E' - F'\n(commits replicados)",
      "example": "git rebase master\nou\ngit rebase -i HEAD~3\nou\ngit rebase --continue (apÃ³s resolver conflitos)"
    },
    "mission": {
      "desc": "Reorganize seus commits sobre outra branch usando rebase.",
      "goal": "FaÃ§a rebase da sua branch sobre master.",
      "steps": ["1. Verifique em qual branch estÃ¡", "2. Digite: git rebase master", "3. Resolva conflitos se houver", "4. Continue: git rebase --continue"],
      "expected": "git rebase master",
      "success": "Rebase realizado com sucesso! HistÃ³rico reorganizado!"
    }
  },
  {
    "id": 22,
    "title": "23. Cherry-pick (Escolher um commit)",
    "tutorial": {
      "desc": "`git cherry-pick` copia um commit especÃ­fico de uma branch para outra. Ãštil quando vocÃª quer uma mudanÃ§a especÃ­fica sem fazer merge de toda a branch.",
      "detailed": "Cherry-pick pega o conteÃºdo de um commit e o aplica em outro lugar. Cria um novo commit com a mesma mudanÃ§a. Diferente de merge que traz todos os commits, cherry-pick escolhe quais levar.",
      "tips": "Use quando: (1) quer uma correÃ§Ã£o especÃ­fica, (2) precisa de apenas uma feature de vÃ¡rias, (3) quer evitar conflitos de merge. Se houver conflitos, resolva e continue com `git cherry-pick --continue`. Use commit hash do `git log` para identificar o commit.",
      "diagram": "Branch A (feature-login):\n  commit 1 (typo fix)\n  commit 2 (auth system)  â† este queremos\n  commit 3 (UI changes)\n\nBranch B (master):\n  commit A\n  commit B\n    â†“\nğŸ”§ git cherry-pick 2\n    â†“\nBranch B (master):\n  commit A\n  commit B\n  commit 2' (auth system - cÃ³pia)",
      "example": "git cherry-pick abc123\nou\ngit cherry-pick abc123 def456 ghi789\nou\ngit cherry-pick --continue (apÃ³s resolver conflitos)"
    },
    "mission": {
      "desc": "Copie um commit especÃ­fico de uma branch para outra.",
      "goal": "Use cherry-pick para aplicar um commit especÃ­fico.",
      "steps": ["1. Encontre o hash: git log", "2. Troque para a branch destino", "3. Digite: git cherry-pick hash", "4. Resolva conflitos se necessÃ¡rio"],
      "expected": "git cherry-pick 123abc",
      "success": "Commit copiado com sucesso!"
    }
  },
  {
    "id": 23,
    "title": "24. Submodules (RepositÃ³rios dentro de repositÃ³rios)",
    "tutorial": {
      "desc": "Submodules permitem incluir um repositÃ³rio git dentro de outro. Ãštil para dependÃªncias reutilizÃ¡veis ou componentes compartilhados entre projetos.",
      "detailed": "Um submodule Ã© um referÃªncia a um commit especÃ­fico de outro repositÃ³rio. VocÃª pode adicionar, atualizar e remover submodules. Cada submodule tem seu prÃ³prio histÃ³rico e branch.",
      "tips": "Use submodules para: (1) bibliotecas compartilhadas, (2) componentes reutilizÃ¡veis, (3) dependÃªncias internas. Cuidado: submodules podem complicar workflows â€” considere usar npm/pip/maven primeiro.",
      "diagram": "ğŸ“¦ RepositÃ³rio Principal\n    â”œâ”€â”€ src/\n    â”œâ”€â”€ .gitmodules\n    â””â”€â”€ vendor/lib/ (submodule)\n         â†“\n        ğŸ“¦ RepositÃ³rio externo\n         (versionado independentemente)",
      "example": "git submodule add https://github.com/user/lib.git vendor/lib\ngit submodule update --init --recursive"
    },
    "mission": {
      "desc": "Aprenda sobre submodules e como adicionÃ¡-los a um repositÃ³rio.",
      "goal": "Adicionar um submodule exemplo (conceitual).",
      "steps": ["1. Veja arquivo: cat .gitmodules", "2. Digite: git config --file .gitmodules --list", "3. Explore: ls vendor/ (se houver submodules)"],
      "expected": "git submodule add <URL> <path>",
      "success": "Submodules compreendidos!"
    }
  },
  {
    "id": 24,
    "title": "25. Hooks (Automatizar aÃ§Ãµes)",
    "tutorial": {
      "desc": "Hooks sÃ£o scripts que o Git executa automaticamente em eventos (commit, push, merge, etc.). Permitem automatizar verificaÃ§Ãµes, linting, testes e outras aÃ§Ãµes.",
      "detailed": "Existem hooks de client-side (pre-commit, commit-msg, post-commit) e server-side (pre-receive, post-receive). Localizados em `.git/hooks/`. Use para aplicar padrÃµes de cÃ³digo e prevenir commits ruins.",
      "tips": "FaÃ§a scripts executÃ¡veis (`chmod +x .git/hooks/pre-commit`). Use ferramentas como Husky para gerenciar hooks em equipes. Sempre documente hooks no README do projeto.",
      "diagram": "âš¡ Evento Git (ex: git commit)\n    â†“\nğŸ” Hook acionado (.git/hooks/pre-commit)\n    â†“\nâœ“ Script executado (linting, testes)\n    â†“\nâœ… Se OK: commit continua\nâŒ Se falhar: commit bloqueado",
      "example": "#!/bin/sh\necho 'Running pre-commit checks...'\nnpm run lint\nexit $?"
    },
    "mission": {
      "desc": "ConheÃ§a hooks e veja onde estÃ£o localizados no repositÃ³rio.",
      "goal": "Explorar a pasta `.git/hooks` e entender a estrutura.",
      "steps": ["1. Digite: ls .git/hooks", "2. Examine exemplo: cat .git/hooks/pre-commit.sample", "3. Crie seu hook customizado se necessÃ¡rio"],
      "expected": "ls .git/hooks",
      "success": "Hooks explorados com sucesso!"
    }
  },
  {
    "id": 25,
    "title": "26. SeguranÃ§a e Boas PrÃ¡ticas",
    "tutorial": {
      "desc": "Dicas essenciais para manter seu repositÃ³rio seguro e as prÃ¡ticas recomendadas ao usar Git em equipes e projetos profissionais.",
      "detailed": "PrincÃ­pios: (1) Nunca commite secrets (senhas, tokens, chaves), (2) Use `.gitignore` para excluir arquivos locais, (3) Sempre revise diffs antes de commit, (4) Proteja branches principais com polÃ­ticas, (5) Mantenha histÃ³rico limpo e descritivo.",
      "tips": "Use `git-secrets` para detectar padrÃµes sensÃ­veis. Implemente hooks de pre-commit. Use variÃ¡veis de ambiente para secrets. Revise PRs com atenÃ§Ã£o. Backup regularmente. Use assinatura de commits (git commit -S) em projetos crÃ­ticos.",
      "diagram": "ğŸ”’ SeguranÃ§a em Git\n    â”œâ”€â”€ âœ… .gitignore (excluir secrets)\n    â”œâ”€â”€ âœ… Pre-commit hooks (validar)\n    â”œâ”€â”€ âœ… Branch protection (bloquear push direto)\n    â”œâ”€â”€ âœ… Code review (revisÃ£o de PRs)\n    â””â”€â”€ âœ… Signed commits (verificaÃ§Ã£o de autoria)",
      "example": "echo 'node_modules/' >> .gitignore\necho '.env' >> .gitignore\ngit rm --cached secret.txt\ngit commit -m \"Remove arquivo sensÃ­vel\""
    },
    "mission": {
      "desc": "Aplicar prÃ¡ticas de seguranÃ§a no repositÃ³rio.",
      "goal": "Criar um `.gitignore` robusto e remover arquivos sensÃ­veis.",
      "steps": ["1. Crie/edite `.gitignore`", "2. Adicione padrÃµes: node_modules/, .env, *.log", "3. Remova arquivo sensÃ­vel: git rm --cached secret.txt", "4. Commit: git commit -m \"SeguranÃ§a: adiciona .gitignore\""],
      "expected": "echo 'node_modules/' >> .gitignore",
      "success": "Boas prÃ¡ticas de seguranÃ§a aplicadas!"
    }
  }
]

